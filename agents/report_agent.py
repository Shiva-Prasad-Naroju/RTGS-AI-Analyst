"""
Report Agent - Generates comprehensive PDF reports
"""
import pandas as pd
import logging
from typing import Dict, List, Any, Optional
import os
from datetime import datetime
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_JUSTIFY

from config import REPORT_CONFIG, PATHS
from utils import get_timestamp

logger = logging.getLogger(__name__)

class ReportAgent:
    """Agent responsible for generating comprehensive PDF reports"""
    
    def __init__(self):
        self.name = "Report Agent"
        self.styles = getSampleStyleSheet()
        self._setup_custom_styles()
        
    def _setup_custom_styles(self):
        """Setup custom paragraph styles"""
        # Title style
        self.styles.add(ParagraphStyle(
            name='CustomTitle',
            parent=self.styles['Title'],
            fontSize=24,
            spaceAfter=30,
            alignment=TA_CENTER,
            textColor=colors.darkblue,
            fontName='Helvetica-Bold'
        ))
        
        # Section header style
        self.styles.add(ParagraphStyle(
            name='SectionHeader',
            parent=self.styles['Heading1'],
            fontSize=16,
            spaceAfter=12,
            spaceBefore=20,
            textColor=colors.darkblue,
            fontName='Helvetica-Bold'
        ))
        
        # Subsection header style
        self.styles.add(ParagraphStyle(
            name='SubsectionHeader',
            parent=self.styles['Heading2'],
            fontSize=14,
            spaceAfter=8,
            spaceBefore=12,
            textColor=colors.darkgreen,
            fontName='Helvetica-Bold'
        ))
        
        # Body text style
        self.styles.add(ParagraphStyle(
            name='CustomBody',
            parent=self.styles['Normal'],
            fontSize=11,
            spaceAfter=6,
            alignment=TA_JUSTIFY,
            fontName='Helvetica'
        ))
        
        # Bullet point style
        self.styles.add(ParagraphStyle(
            name='BulletPoint',
            parent=self.styles['Normal'],
            fontSize=11,
            spaceAfter=4,
            leftIndent=20,
            fontName='Helvetica'
        ))
        
        # Key metric style
        self.styles.add(ParagraphStyle(
            name='KeyMetric',
            parent=self.styles['Normal'],
            fontSize=12,
            spaceAfter=6,
            textColor=colors.darkred,
            fontName='Helvetica-Bold'
        ))
    
    def _create_header_footer(self, canvas, doc):
        """Create header and footer for pages"""
        # Header
        canvas.saveState()
        canvas.setFont('Helvetica-Bold', 10)
        canvas.drawString(doc.leftMargin, doc.height + doc.topMargin - 20, 
                         "RTGS AI Analyst - Data Quality Report")
        
        # Footer
        canvas.setFont('Helvetica', 9)
        canvas.drawString(doc.leftMargin, 30, 
                         f"Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        canvas.drawRightString(doc.width + doc.leftMargin, 30, 
                              f"Page {doc.page}")
        canvas.restoreState()
    
    def _create_title_page(self) -> List:
        """Create the title page content"""
        content = []
        
        # Main title
        title = Paragraph("RTGS AI Analyst", self.styles['CustomTitle'])
        content.append(title)
        content.append(Spacer(1, 20))
        
        # Subtitle
        subtitle = Paragraph("Comprehensive Data Quality Analysis Report", 
                            self.styles['Heading1'])
        content.append(subtitle)
        content.append(Spacer(1, 40))
        
        # Report info
        report_info = [
            ["Report Type:", "Data Quality Analysis"],
            ["Generated By:", "RTGS AI Analyst Multi-Agent System"],
            ["Generated On:", datetime.now().strftime('%Y-%m-%d %H:%M:%S')],
            ["Report Version:", "1.0"]
        ]
        
        info_table = Table(report_info, colWidths=[2*inch, 3*inch])
        info_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 11),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ]))
        
        content.append(info_table)
        content.append(Spacer(1, 40))
        
        # Executive summary teaser
        exec_summary = Paragraph("""
        This report provides a comprehensive analysis of your dataset's quality, 
        including identification of data issues, cleaning recommendations, and 
        transformation results. The RTGS AI Analyst system has automatically 
        processed your data through multiple specialized agents to deliver 
        actionable insights and a production-ready dataset.
        """, self.styles['CustomBody'])
        
        content.append(exec_summary)
        content.append(PageBreak())
        
        return content
    
    def _create_executive_summary(self, analysis_results: Dict[str, Any]) -> List:
        """Create executive summary section"""
        content = []
        
        # Section header
        header = Paragraph("Executive Summary", self.styles['SectionHeader'])
        content.append(header)
        
        # Get key metrics
        raw_analysis = analysis_results.get('raw_dataset_analysis', {})
        cleaned_analysis = analysis_results.get('cleaned_dataset_analysis', {})
        
        raw_score = raw_analysis.get('quality_score', 0)
        final_score = cleaned_analysis.get('final_quality_score', 0)
        improvement = final_score - raw_score
        
        # Key findings
        key_findings = f"""
        The RTGS AI Analyst system has successfully processed your dataset and 
        achieved a significant quality improvement. The data quality score improved 
        from {raw_score:.1f}/100 to {final_score:.1f}/100, representing a 
        {improvement:+.1f} point improvement.
        """
        
        content.append(Paragraph(key_findings, self.styles['CustomBody']))
        content.append(Spacer(1, 12))
        
        # Quality status
        if final_score >= 90:
            status = "EXCELLENT - Dataset is ready for advanced analytics"
            color = colors.darkgreen
        elif final_score >= 75:
            status = "GOOD - Dataset is suitable for most analytical purposes"
            color = colors.orange
        elif final_score >= 60:
            status = "ACCEPTABLE - Dataset can be used with some limitations"
            color = colors.darkorange
        else:
            status = "NEEDS IMPROVEMENT - Additional work recommended"
            color = colors.darkred
        
        status_style = ParagraphStyle(
            name='Status',
            parent=self.styles['CustomBody'],
            fontSize=12,
            textColor=color,
            fontName='Helvetica-Bold',
            alignment=TA_CENTER
        )
        
        content.append(Paragraph(f"Data Quality Status: {status}", status_style))
        content.append(Spacer(1, 20))
        
        # Executive summary from analysis
        exec_summary_text = analysis_results.get('executive_summary', '')
        if exec_summary_text:
            content.append(Paragraph(exec_summary_text, self.styles['CustomBody']))
        
        content.append(PageBreak())
        return content
    
    def _create_raw_dataset_analysis(self, raw_analysis: Dict[str, Any]) -> List:
        """Create raw dataset analysis section"""
        content = []
        
        # Section header
        header = Paragraph("Raw Dataset Analysis", self.styles['SectionHeader'])
        content.append(header)
        
        # Dataset overview
        overview_header = Paragraph("Dataset Overview", self.styles['SubsectionHeader'])
        content.append(overview_header)
        
        overview = raw_analysis.get('dataset_overview', {})
        shape = overview.get('shape', (0, 0))
        memory_mb = overview.get('memory_usage_mb', 0)
        missing_summary = overview.get('missing_data_summary', 'N/A')
        
        overview_text = f"""
        The original dataset contains {shape[0]:,} rows and {shape[1]} columns, 
        with a memory footprint of {memory_mb:.1f} MB. {missing_summary}
        """
        
        content.append(Paragraph(overview_text, self.styles['CustomBody']))
        content.append(Spacer(1, 12))
        
        # Vulnerabilities identified
        vulnerabilities_header = Paragraph("Vulnerabilities Identified", self.styles['SubsectionHeader'])
        content.append(vulnerabilities_header)
        
        vulnerabilities = raw_analysis.get('vulnerabilities', [])
        if vulnerabilities:
            for vuln in vulnerabilities:
                bullet = Paragraph(f"• {vuln}", self.styles['BulletPoint'])
                content.append(bullet)
        else:
            content.append(Paragraph("No major vulnerabilities identified.", self.styles['CustomBody']))
        
        content.append(Spacer(1, 12))
        
        # Recommendations
        recommendations_header = Paragraph("Initial Recommendations", self.styles['SubsectionHeader'])
        content.append(recommendations_header)
        
        recommendations = raw_analysis.get('recommendations', [])
        if recommendations:
            for rec in recommendations:
                bullet = Paragraph(f"• {rec}", self.styles['BulletPoint'])
                content.append(bullet)
        else:
            content.append(Paragraph("No specific recommendations at this stage.", self.styles['CustomBody']))
        
        # LLM insights if available
        llm_insights = raw_analysis.get('llm_insights', '')
        if llm_insights and llm_insights != "LLM analysis unavailable":
            content.append(Spacer(1, 12))
            insights_header = Paragraph("AI Analyst Insights", self.styles['SubsectionHeader'])
            content.append(insights_header)
            content.append(Paragraph(llm_insights, self.styles['CustomBody']))
        
        content.append(PageBreak())
        return content
    
    def _create_cleaning_transformation_analysis(self, cleaned_analysis: Dict[str, Any]) -> List:
        """Create cleaning and transformation analysis section"""
        content = []
        
        # Section header
        header = Paragraph("Data Cleaning & Transformation Results", self.styles['SectionHeader'])
        content.append(header)
        
        # Improvement summary
        improvement_header = Paragraph("Improvement Summary", self.styles['SubsectionHeader'])
        content.append(improvement_header)
        
        improvement_summary = cleaned_analysis.get('improvement_summary', {})
        original_shape = improvement_summary.get('original_shape', (0, 0))
        final_shape = improvement_summary.get('final_shape', (0, 0))
        actions_applied = improvement_summary.get('actions_applied', 0)
        
        improvement_text = f"""
        The data processing pipeline successfully transformed the dataset from 
        {original_shape[0]:,} rows × {original_shape[1]} columns to 
        {final_shape[0]:,} rows × {final_shape[1]} columns. A total of 
        {actions_applied} cleaning and transformation actions were applied.
        """
        
        content.append(Paragraph(improvement_text, self.styles['CustomBody']))
        content.append(Spacer(1, 12))
        
        # Changes made
        changes_header = Paragraph("Actions Performed", self.styles['SubsectionHeader'])
        content.append(changes_header)
        
        changes_made = cleaned_analysis.get('changes_made', {})
        cleaning_actions = changes_made.get('cleaning_actions', [])
        transformations = changes_made.get('transformations', [])
        
        if cleaning_actions:
            content.append(Paragraph("Data Cleaning Actions:", self.styles['KeyMetric']))
            for action in cleaning_actions[:10]:  # Limit to first 10
                bullet = Paragraph(f"• {action}", self.styles['BulletPoint'])
                content.append(bullet)
            content.append(Spacer(1, 8))
        
        if transformations:
            content.append(Paragraph("Data Transformations:", self.styles['KeyMetric']))
            for transform in transformations[:10]:  # Limit to first 10
                bullet = Paragraph(f"• {transform}", self.styles['BulletPoint'])
                content.append(bullet)
            content.append(Spacer(1, 8))
        
        # Improvements achieved
        improvements_header = Paragraph("Improvements Achieved", self.styles['SubsectionHeader'])
        content.append(improvements_header)
        
        improvements = cleaned_analysis.get('improvements', [])
        if improvements:
            for improvement in improvements:
                bullet = Paragraph(f"• {improvement}", self.styles['BulletPoint'])
                content.append(bullet)
        else:
            content.append(Paragraph("No specific improvements documented.", self.styles['CustomBody']))
        
        # Remaining issues
        remaining_issues = cleaned_analysis.get('remaining_issues', [])
        if remaining_issues:
            content.append(Spacer(1, 12))
            issues_header = Paragraph("Remaining Issues", self.styles['SubsectionHeader'])
            content.append(issues_header)
            
            for issue in remaining_issues:
                bullet = Paragraph(f"• {issue}", self.styles['BulletPoint'])
                content.append(bullet)
        
        # LLM insights if available
        llm_insights = cleaned_analysis.get('llm_insights', '')
        if llm_insights and llm_insights != "LLM analysis unavailable":
            content.append(Spacer(1, 12))
            insights_header = Paragraph("AI Analyst Insights", self.styles['SubsectionHeader'])
            content.append(insights_header)
            content.append(Paragraph(llm_insights, self.styles['CustomBody']))
        
        content.append(PageBreak())
        return content
    
    def _create_quality_metrics_summary(self, verification_results: Dict[str, Any]) -> List:
        """Create quality metrics summary section"""
        content = []
        
        # Section header
        header = Paragraph("Data Quality Metrics", self.styles['SectionHeader'])
        content.append(header)
        
        # Overall quality score
        quality_score = verification_results.get('quality_score', 0)
        verification_data = verification_results.get('verification_results', {})
        overall_assessment = verification_data.get('overall_assessment', {})
        
        quality_text = f"""
        The final dataset achieved a data quality score of {quality_score:.1f}/100. 
        This score is based on comprehensive checks including data completeness, 
        consistency, distribution analysis, and structural integrity.
        """
        
        content.append(Paragraph(quality_text, self.styles['CustomBody']))
        content.append(Spacer(1, 12))
        
        # Quality breakdown table
        quality_breakdown = [
            ["Quality Aspect", "Status", "Details"],
        ]
        
        for check_name, check_result in verification_data.items():
            if check_name == 'overall_assessment':
                continue
                
            status = check_result.get('status', 'unknown').upper()
            issues_count = len(check_result.get('issues', []))
            warnings_count = len(check_result.get('warnings', []))
            
            details = f"{issues_count} issues, {warnings_count} warnings"
            quality_breakdown.append([
                check_name.replace('_', ' ').title(),
                status,
                details
            ])
        
        quality_table = Table(quality_breakdown, colWidths=[2*inch, 1*inch, 2*inch])
        quality_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 11),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        
        content.append(quality_table)
        content.append(Spacer(1, 20))
        
        # Readiness assessment
        readiness_header = Paragraph("Analysis Readiness Assessment", self.styles['SubsectionHeader'])
        content.append(readiness_header)
        
        # Get readiness info from analysis results if available
        readiness_info = "Dataset readiness assessment not available."
        try:
            # This would come from the cleaned analysis results
            readiness_info = "The dataset has been assessed for analysis readiness based on data quality, completeness, and structural integrity."
        except:
            pass
        
        content.append(Paragraph(readiness_info, self.styles['CustomBody']))
        
        content.append(PageBreak())
        return content
    
    def _create_recommendations_section(self, analysis_results: Dict[str, Any]) -> List:
        """Create recommendations and next steps section"""
        content = []
        
        # Section header
        header = Paragraph("Recommendations & Next Steps", self.styles['SectionHeader'])
        content.append(header)
        
        # Future recommendations
        cleaned_analysis = analysis_results.get('cleaned_dataset_analysis', {})
        future_recommendations = cleaned_analysis.get('future_recommendations', [])
        
        if future_recommendations:
            recs_header = Paragraph("Recommended Actions", self.styles['SubsectionHeader'])
            content.append(recs_header)
            
            for i, rec in enumerate(future_recommendations, 1):
                bullet = Paragraph(f"{i}. {rec}", self.styles['BulletPoint'])
                content.append(bullet)
            
            content.append(Spacer(1, 12))
        
        # Analysis opportunities
        opportunities_header = Paragraph("Analysis Opportunities", self.styles['SubsectionHeader'])
        content.append(opportunities_header)
        
        # Generate analysis opportunities based on final dataset characteristics
        opportunities_text = """
        Based on the cleaned dataset characteristics, the following analytical 
        approaches are recommended:
        
        • Descriptive Analytics: Explore data distributions and summary statistics
        • Correlation Analysis: Investigate relationships between variables
        • Segmentation Analysis: Group data based on categorical variables
        • Trend Analysis: If temporal data is available, analyze patterns over time
        • Predictive Modeling: Consider machine learning approaches if target variables exist
        """
        
        content.append(Paragraph(opportunities_text, self.styles['CustomBody']))
        content.append(Spacer(1, 12))
        
        # Data governance recommendations
        governance_header = Paragraph("Data Governance Recommendations", self.styles['SubsectionHeader'])
        content.append(governance_header)
        
        governance_text = """
        To maintain data quality in future iterations:
        
        • Implement automated data validation checks
        • Establish data quality monitoring dashboards
        • Create standard operating procedures for data ingestion
        • Regular quality audits and reviews
        • Documentation of data lineage and transformations
        """
        
        content.append(Paragraph(governance_text, self.styles['CustomBody']))
        
        content.append(PageBreak())
        return content
    
    def _create_appendix(self, analysis_results: Dict[str, Any]) -> List:
        """Create appendix with technical details"""
        content = []
        
        # Section header
        header = Paragraph("Technical Appendix", self.styles['SectionHeader'])
        content.append(header)
        
        # Processing summary
        processing_header = Paragraph("Processing Summary", self.styles['SubsectionHeader'])
        content.append(processing_header)
        
        # Agent execution summary
        agents_summary = """
        The RTGS AI Analyst system executed the following agents in sequence:
        
        1. Ingestion Agent: Loaded and validated the dataset
        2. Inspection Agent: Identified data quality issues and vulnerabilities
        3. Cleaning Agent: Applied data cleaning with human-in-the-loop confirmation
        4. Transformation Agent: Performed feature engineering and data preparation
        5. Verification Agent: Validated final data quality
        6. Analysis Agent: Generated insights using AI-powered analysis
        7. Visualization Agent: Created comparison charts and visualizations
        8. Report Agent: Generated this comprehensive report
        """
        
        content.append(Paragraph(agents_summary, self.styles['CustomBody']))
        content.append(Spacer(1, 12))
        
        # Technical specifications
        tech_header = Paragraph("Technical Specifications", self.styles['SubsectionHeader'])
        content.append(tech_header)
        
        tech_specs = [
            ["Component", "Technology"],
            ["Data Processing", "Pandas, NumPy"],
            ["Machine Learning", "Scikit-learn"],
            ["Visualization", "Matplotlib, Seaborn"],
            ["Report Generation", "ReportLab"],
            ["AI Analysis", "LangChain, ChatGroq/OpenAI"],
            ["Statistical Analysis", "SciPy, Statsmodels"]
        ]
        
        tech_table = Table(tech_specs, colWidths=[2.5*inch, 2.5*inch])
        tech_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 11),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        
        content.append(tech_table)
        content.append(Spacer(1, 20))
        
        # Contact and support info
        support_header = Paragraph("Support & Contact", self.styles['SubsectionHeader'])
        content.append(support_header)
        
        support_text = """
        For questions about this report or the RTGS AI Analyst system:
        
        • System: RTGS AI Analyst Multi-Agent System
        • Version: 1.0 (MVP)
        • Documentation: Available in project repository
        • Support: Review logs and configuration files for troubleshooting
        """
        
        content.append(Paragraph(support_text, self.styles['CustomBody']))
        
        return content
    
    def generate_report(self, output_path: str, analysis_results: Dict[str, Any],
                       verification_results: Dict[str, Any]) -> str:
        """Generate the complete PDF report"""
        
        logger.info(f"{self.name}: Generating comprehensive PDF report...")
        
        # Ensure output directory exists
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        
        # Create document
        doc = SimpleDocTemplate(
            output_path,
            pagesize=A4,
            rightMargin=REPORT_CONFIG['margin']*inch,
            leftMargin=REPORT_CONFIG['margin']*inch,
            topMargin=REPORT_CONFIG['margin']*inch,
            bottomMargin=REPORT_CONFIG['margin']*inch
        )
        
        # Build content
        content = []
        
        # Title page
        logger.info(f"{self.name}: Creating title page...")
        content.extend(self._create_title_page())
        
        # Executive summary
        logger.info(f"{self.name}: Creating executive summary...")
        content.extend(self._create_executive_summary(analysis_results))
        
        # Raw dataset analysis
        logger.info(f"{self.name}: Creating raw dataset analysis...")
        raw_analysis = analysis_results.get('raw_dataset_analysis', {})
        content.extend(self._create_raw_dataset_analysis(raw_analysis))
        
        # Cleaning and transformation analysis
        logger.info(f"{self.name}: Creating cleaning analysis...")
        cleaned_analysis = analysis_results.get('cleaned_dataset_analysis', {})
        content.extend(self._create_cleaning_transformation_analysis(cleaned_analysis))
        
        # Quality metrics summary
        logger.info(f"{self.name}: Creating quality metrics...")
        content.extend(self._create_quality_metrics_summary(verification_results))
        
        # Recommendations
        logger.info(f"{self.name}: Creating recommendations...")
        content.extend(self._create_recommendations_section(analysis_results))
        
        # Appendix
        logger.info(f"{self.name}: Creating appendix...")
        content.extend(self._create_appendix(analysis_results))
        
        # Build PDF
        doc.build(content, onFirstPage=self._create_header_footer, 
                 onLaterPages=self._create_header_footer)
        
        logger.info(f"{self.name}: PDF report generated successfully: {output_path}")
        return output_path
    
    def process(self, analysis_results: Dict[str, Any], 
                verification_results: Dict[str, Any]) -> Dict[str, Any]:
        """
        Main processing method for the Report Agent
        
        Args:
            analysis_results: Results from analysis agent
            verification_results: Results from verification agent
            
        Returns:
            Report generation results
        """
        logger.info(f"{self.name}: Starting comprehensive report generation")
        
        try:
            # Create output filename
            timestamp = get_timestamp()
            filename = f"data_analysis_report_{timestamp}.pdf"
            output_path = os.path.join(PATHS.outputs_reports, filename)
            
            # Generate report
            report_path = self.generate_report(output_path, analysis_results, verification_results)
            
            # Calculate file size
            file_size = os.path.getsize(report_path) / (1024 * 1024)  # MB
            
            result = {
                'agent': self.name,
                'status': 'success',
                'report_path': report_path,
                'file_size_mb': round(file_size, 2),
                'pages_generated': 'Multiple sections with technical analysis',
                'message': f"Comprehensive report generated successfully. File size: {file_size:.2f} MB"
            }
            
            logger.info(f"{self.name}: Report generation completed successfully")
            logger.info(f"  - Report created: {report_path}")
            logger.info(f"  - File size: {file_size:.2f} MB")
            
            return result
            
        except Exception as e:
            error_msg = f"Report generation failed: {str(e)}"
            logger.error(f"{self.name}: {error_msg}")
            
            return {
                'agent': self.name,
                'status': 'error',
                'message': error_msg,
                'error': str(e)
            }